# Фінальний проект - Алгоритми

## Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Для реалізації однозв'язного списку:
- написано функцію, яка реалізує реверсування однозв'язного списку, змінюючи посилання між вузлами;
- програмно реалізовано алгоритм сортування (функцію) злиттям для однозв'язного списку;
- написано функцію, що об'єднує два відсортовані однозв'язні списки в один відсортований список.

## Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

Написано програму на Python, яка використовує рекурсію для створення фрактала “дерево Піфагора”. Програма візуалізує фрактал “дерево Піфагора”, і користувач має можливість вказати рівень рекурсії.

## Завдання 3. Дерева, алгоритм Дейкстри

Розроблено алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі, використовуючи бінарну купу (піраміду). Завдання включає створення графа, використання піраміди для оптимізації вибору вершин та обчислення найкоротшіх відстаней та повних шляхів від початкової вершини до всіх інших вершин графа.

## Завдання 4. Візуалізація піраміди

Побудувано функцію, що створює і візуалізує дерево з бінарної купи. Для візуалізації бінарної купи було обрано одну лінію метро, що дозволило зберегти наочність структури.

## Завдання 5. Візуалізація обходу бінарного дерева

Використовуючи код із завдання 4 створено програму на Python, яка візуалізує обходи дерева: у глибину та в ширину. Вона відображає кожен крок у вузлах з різними кольорами, використовуючи 16-систему RGB (приклад #1296F0). Кольори вузлів змінюються від темних до світлих відтінків, залежно від послідовності обходу. Кожен вузол при його відвідуванні отримує унікальний колір, який візуально відображає порядок обходу. Виконано із застосуванням стеку та черги, НЕ рекурсії.

## Завдання 6. Жадібні алгоритми та динамічне програмування

Написано програму на Python, яка використовує два підходи — жадібний алгоритм та алгоритм динамічного програмування для розв’язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету. Кожен вид їжі має вказану вартість і калорійність. Дані про їжу представлені у вигляді словника, де ключ — назва страви, а значення — це словник з вартістю та калорійністю.

Функція greedy_algorithm жадібного алгоритму вибирає страви, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.

Функція dynamic_programming обчислює оптимальний набір страв для максимізації калорійності при заданому бюджеті за допомогою алгоритму динамічного програмування.

## Завдання 7. Використання методу Монте-Карло

Написано програму на Python, яка імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, і визначає ймовірність кожної можливої суми.

Створено симуляцію, де два кубики кидаються велику кількість разів. Для кожного кидка визначається сума чисел, які випали на обох кубиках. Підраховується, скільки разів кожна можлива сума (від 2 до 12) з’являється у процесі симуляції. Використовуючи ці дані, обчислюється імовірність кожної суми.

На основі проведених імітацій створено таблицю, яка відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло. Таблиця ймовірностей сум при киданні двох кубиків містить поле "сума", "імовірність (симуляція)", "імовірність (аналітична)", "похибка".

Порівняно отримані за допомогою методу Монте-Карло результати з аналітичними розрахунками (наведені в завданні).

### Висновки:

Отримані в результаті симуляції 1 000 000 кидків двох ігрових кубиків методом Монте-Карло результати порівняно з аналітичними ймовірностями, обчисленими за класичною формулою, мають дуже невелику похибку. Середнє абсолютне відхилення при 1_000_000 кидків склало 0.02%. Результати підтверджують правильність моделювання та дозволяють робити статистичні висновки за допомогою методу Монте-Карло.
