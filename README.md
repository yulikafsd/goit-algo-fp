# Фінальний проект - Алгоритми

## Завдання 1. Структури даних. Сортування. Робота з однозв'язним списком

Для реалізації однозв'язного списку:
- написано функцію, яка реалізує реверсування однозв'язного списку, змінюючи посилання між вузлами;
- програмно реалізовано алгоритм сортування (функцію) злиттям для однозв'язного списку;
- написано функцію, що об'єднує два відсортовані однозв'язні списки в один відсортований список.

## Завдання 2. Рекурсія. Створення фрактала “дерево Піфагора” за допомогою рекурсії

Написано програму на Python, яка використовує рекурсію для створення фрактала “дерево Піфагора”. Програма візуалізує фрактал “дерево Піфагора”, і користувач має можливість вказати рівень рекурсії.

### Критерії:

- Код виконується. Програма візуалізує фрактал “дерево Піфагора”.
- Користувач має можливість вказати рівень рекурсії.

## Завдання 3. Дерева, алгоритм Дейкстри

Розроблено алгоритм Дейкстри для знаходження найкоротших шляхів у зваженому графі, використовуючи бінарну купу. Завдання включає створення графа, використання піраміди для оптимізації вибору вершин та обчислення найкоротших шляхів від початкової вершини до всіх інших.

### Критерії:

- Програмно реалізовано алгоритм Дейкстри для знаходження найкоротшого шляху у графі з використанням бінарної купи (піраміди).
- У межах реалізації завдання створено граф, використано піраміду для оптимізації вибору вершин та виконано обчислення найкоротших шляхів від початкової вершини до всіх інших.

## Завдання 4. Візуалізація піраміди

Побудувано функцію, що створює і візуалізує дерево з бінарної купи.

### Критерії:

Код виконується. Функція візуалізує бінарну купу.

## Завдання 5. Візуалізація обходу бінарного дерева

Використовуючи код із завдання 4 створено програму на Python, яка візуалізує обходи дерева: у глибину та в ширину. Вона відображає кожен крок у вузлах з різними кольорами, використовуючи 16-систему RGB (приклад #1296F0). Кольори вузлів змінюються від темних до світлих відтінків, залежно від послідовності обходу. Кожен вузол при його відвідуванні отримує унікальний колір, який візуально відображає порядок обходу. Виконано із застосуванням стеку та черги, НЕ рекурсії.

### Критерії:

- Програмно реалізовано алгоритми DFS і BFS для візуалізації обходу дерева в глибину та в ширину. Використано стек та чергу.
- Кольори вузлів змінюються від темних до світлих відтінків залежно від порядку обходу.

## Завдання 6. Жадібні алгоритми та динамічне програмування

Написано програму на Python, яка використовує два підходи — жадібний алгоритм та алгоритм динамічного програмування для розв’язання задачі вибору їжі з найбільшою сумарною калорійністю в межах обмеженого бюджету. Кожен вид їжі має вказану вартість і калорійність. Дані про їжу представлені у вигляді словника, де ключ — назва страви, а значення — це словник з вартістю та калорійністю.

Функція greedy_algorithm жадібного алгоритму вибирає страви, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.

Функція dynamic_programming обчислює оптимальний набір страв для максимізації калорійності при заданому бюджеті за допомогою алгоритму динамічного програмування.

### Критерії:

- Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає назви страв, максимізуючи співвідношення калорій до вартості, не перевищуючи заданий бюджет.
- Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає оптимальний набір страв для максимізації калорійності при заданому бюджеті.

## Завдання 7. Використання методу Монте-Карло

Написано програму на Python, яка імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, і визначає ймовірність кожної можливої суми.

Створено симуляцію, де два кубики кидаються велику кількість разів. Для кожного кидка визначається сума чисел, які випали на обох кубиках. Підраховується, скільки разів кожна можлива сума (від 2 до 12) з’являється у процесі симуляції. Використовуючи ці дані, обчислюється імовірність кожної суми.

На основі проведених імітацій створено таблицю, яка відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло. Таблиця ймовірностей сум при киданні двох кубиків містить поле "сума", "імовірність %", "імовірність виду 1/36".

Порівняно отримані за допомогою методу Монте-Карло результати з аналітичними розрахунками (наведені в завданні).

### Критерії:

- Програмно реалізовано алгоритм для моделювання кидання двох ігрових кубиків і побудови таблиці сум та їх імовірностей за допомогою методу Монте-Карло.
- Код виконується та імітує велику кількість кидків кубиків, обчислює суми чисел, які випадають на кубиках, підраховує, скільки разів кожна можлива сума з’являється у процесі симуляції, і визначає ймовірність кожної можливої суми.
- Створено таблицю або графік, який відображає ймовірності кожної суми, виявлені за допомогою методу Монте-Карло.
- Зроблено висновки щодо правильності розрахунків шляхом порівняння отриманих за допомогою методу Монте-Карло результатів та результатів аналітичних розрахунків. Висновки оформлено у вигляді файлу readme.md фінального завдання.
